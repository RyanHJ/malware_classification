from inspect import getmembers, isfunction
import feature_functions
from os import listdir
from os.path import isfile, join
import re
import psycopg2
import connect
import os
import string
from collections import defaultdict

WRITE_TO_FILE = False

#feature_tuple = (file_in,segment,'', '', opcode, '', malware_class)       

def get_counts(rows):
    segment_dict = defaultdict(int)
    opcode_dict = defaultdict(int)
    for row in rows:
        segment_dict[row[1]] += 1
        opcode_dict[row[4]] += 1

    segment = ",".join(["=".join([key, str(val)]) for key, val in segment_dict.items()])
    opcode = ",".join(["=".join([key, str(val)]) for key, val in opcode_dict.items()])

    return (segment, opcode)

def chunks(l, n):
    """Yield successive n-sized chunks from l."""
    for i in xrange(0, len(l), n):
        yield l[i:i+n]

def parse_line(line,file_in,malware_class):
    error_count = 0

    line = line.replace('\r', '').replace('\n', '')

    ############ Extract the segment ###############
    # Split on ':' and grab first section and remove the period
    split_segment_data = line.split(':')
    segment = split_segment_data[0].replace('.','')
    
    ########## Extract the address ###########
    # Address to left[0], rest of data to the right[1]
    split_address_data = split_segment_data[1].split(' ')
    # Remove any \r or \n remaining
    address = split_address_data[0].replace('\t','')
    
    ######## Extract the bytes #########
    # Use segment split and split on '\t\t' to get everything from the end of bytes to the 
    # left in element [0] and the rest of the line data to the right
    split_bytes_data = split_segment_data[1].split('\t\t')
    # Split on the first space, now bytes should be in element 1(If there are any)
    
    split_segment_bytes = split_bytes_data[0].split(' ', 1)
    
    # Check if there are bytes (opcode, operands):
    bytes = ''
    opcode= ''
    operands=''
    
    if len(split_segment_bytes) > 1:
        # Clean up
        bytes = split_segment_bytes[1].replace('\t',' ').replace('\r', ' ').replace('+', '').replace(" ", "")
        
        #####
        # NOTE: There will only be an opcode if there are bytes - so 
        # we will extract within the if statement
        ######
        ############ Extract the opcode ###########
        # Split on the last occurrence of \t that will occur after bytes
        #split_opcode = line.replace('\t', ' ')
        
        split_opcode = line.rsplit('\t',1)
        # Only proceed if there is opcode data:
        
        if len(split_opcode) > 1:
            # Strip all initial spaces
            opcode_data = split_opcode[1].lstrip()
            # Split on first space, opcode should be to left, operands to right
            
            split_opcode_operands = opcode_data.split(' ', 1)
            # Extract opcode and cleanup
            opcode = split_opcode_operands[0].replace('\r','').replace('\n', '')
            
            # STAY IN IF STATEMENT FOR OPERANDS SINCE THEY WILL ONLY BE THERE
            # IF AN OPCODE EXISTS
            ########## Extract the operands #########
            if len(split_opcode_operands) > 1:
                # Cleanup operands
                operands = split_opcode_operands[1].lstrip().replace('\r','').replace('\n','').replace(' ', '')
                
    if opcode.isalpha():
        #feature_tuple = (file_in,segment,address, bytes, opcode, operands, malware_class)       
        feature_tuple = (file_in,segment,'', '', opcode, '', malware_class)       
        error_count = error_count + 1
    else:
        feature_tuple = (file_in,segment,'','','','',malware_class)
        
    return (feature_tuple, error_count)
                    
def extract_columns(file_in, file_out,file_to_malware):
    """ 
    Takes in a filename and returns a list of tuples with the columns of each line.
    Also takes in the filename to malware in order to append to columns
    Returns: List of (Segment, Address, Bytes, opcode, operands)
    """
    if WRITE_TO_FILE:
        file_out_writer = open(file_out,'w')
        
    lines= []
    count = 0
    malware_class = get_malware_class(file_in,file_to_malware)

    f = open(file_in, 'r')
    #for x in range(50):
    #line = f.next().strip()
    for line in open(file_in, 'r'):
        (feature_tuple,error_count) = parse_line(line,file_in,malware_class)
        lines.append(feature_tuple)
        count = count + error_count

        if WRITE_TO_FILE:
            # Write line to file
            feature_line = '{0}|{1}|{2}|{3}|{4}\n'.format(segment,address,bytes,opcode,operands)
            file_out_writer.write(feature_line)

    if WRITE_TO_FILE:
        file_out_writer.close()

    # Write all lines to file
    (seg_dict, op_dict) = get_counts(lines)
    feature_tuple = (seg_dict, op_dict, file_in, malware_class)
    connect.insert_file_info(feature_tuple)
    
    return lines

def load_columns(folder_dir):
    """
    Loads all of the feature.csv;s into memory
    Returns a list of lists
    """ 
    csv_path = "../features/"
    #### Get a list of all csv files######
    csv_files = [ f for f in listdir(csv_path) if isfile(join(csv_path,f)) and f.endswith('.csv')]
    print("There are {:d} csv files".format(len(csv_files)))
    
    files_columns = []
    #[files_columns.append(line.split('|')) for line in open(file,'r') for file in csv_files]

def get_header(feature_functions_list):
    """ 
    Returns a column header generated from the feature_function_list
    """
    names = list(map((lambda x: x[0]), feature_functions_list))
    names.append("malware_class")
    names.insert(0,"filename")
    return ",".join(names)

def get_malware_dict(filename, return_string=True):
    """
    Extracts which maleware class the given filename is
    and builds a dictionary from the data.
    """
    malware_mappings = {}
    malware_mappings[1] = "Ramnit"
    malware_mappings[2] = "Lollipop"
    malware_mappings[3] = "Kelihos_ver3"
    malware_mappings[4] = "Vundo"
    malware_mappings[5] = "Simda"
    malware_mappings[6] = "Tracur"
    malware_mappings[7] = "Kelihos_ver1"
    malware_mappings[8] = "Obfuscator.ACY"
    malware_mappings[9] = "Gatak"

    file_to_malware = {}
    f = open(filename, 'r')
    for line in f.readlines()[1:]:
        split = line.split(',')
        (filename,mal_class) = split[0].replace('\"', ''), int(split[1])
        file_to_malware[filename] = mal_class
        
        # Return in string form
        if return_string:
            file_to_malware[filename] = malware_mappings[mal_class]

    return file_to_malware
    
def get_malware_class(file_in, file_to_malware):
    """
    Returns the malware classification of file
    """
    # Get just the filename without extension
    malware_filename = file_in.rsplit('/', 1)[1].split('.')[0]
    # Extract the malware class
    return file_to_malware[malware_filename]

def extract_features(feature_functions_list,file_in,file_out,file_to_malware):
    """
    Takes in the line columns produced from extract_columns and generates features
    from them based on the list of feature_functions passed in.

    Note:
       Each feature_function should return a single value based on the list of tuples.
    """
    line_columns = extract_columns(file_in, file_out,file_to_malware)
    
    #for line in line_columns:
    #   print line


    feature_list = []
    """
    for feature_func in feature_functions_list:
        value = feature_func[1](line_columns)
        feature_list.append(value)
        
        #UNCOMMENT TO SEE FEATURE FUNCTION NAME AND VALUE
        #print "{0}: {1}".format(feature_func[0], value)
    """
    return feature_list

def get_file_features(file_in,file_out,feature_functions_list,file_to_malware):
    """
    Returns a list representing the file features
    """

    file_features = extract_features(feature_functions_list,file_in,file_out,file_to_malware)
    malware_class = get_malware_class(file_in,file_to_malware)

    # Insert filename at the front
    malware_filename = file_in.rsplit('/', 1)[1]
    file_features.insert(0, malware_filename)

    # Append malware class at the end
    file_features.append(malware_class)

    return file_features

def generate_csv_files():
    asm_path = "../train/"
    feature_path = "../features/"
    labels_file = "../labels/trainLabels.csv"

    # Build the filename -> Malware class dictionary:
    file_to_malware = get_malware_dict(labels_file)

    # Loads all feature functions from the feature_functions module
    feature_functions_list = [o for o in getmembers(feature_functions) if isfunction(o[1])]

    # Generate header
    header = get_header(feature_functions_list)

    #### Get a list of all asm files######
    asm_files = [ f for f in listdir(asm_path) if isfile(join(asm_path,f)) and f.endswith('.asm')]

    ##### Extract features for each file in asm file list #######
    files_features = []
    count = 1
    asm_files = asm_files
    for asm_file in asm_files:
        print("******* Processing {0} ({1}/{2})********".format(asm_file,count,len(asm_files)))
        count = count + 1

        file_out = join(feature_path,asm_file + "_features.csv")
        file_in = join(asm_path,asm_file)
        #file_out = file_in + "_features.csv"
        
        file_features = get_file_features(file_in,file_out,feature_functions_list, file_to_malware)
        files_features.append(file_features)

        new_loc = join("../parsed/",asm_file)
        
        os.rename(file_in, new_loc)

if __name__ == "__main__":
    generate_csv_files()

    file_dir = "../features"
    #load_columns(file_dir)
    

    """
    output_file = "all_results.csv"
    f = open(output_file, 'w')
    f.write(header + "\n")

    print header
    for line in files_features:
        # Convert to csv line
        line = ','.join(str(x) for x in line)
        f.write(line + "\n")

        print line

    f.close()
    """
