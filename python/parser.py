from os import listdir
from os.path import isfile, join
import re
import psycopg2
import connect
import os
import string
import utilities
from collections import defaultdict

WRITE_TO_FILE = False

def get_counts(rows):
    segment_dict = defaultdict(int)
    opcode_dict = defaultdict(int)
    for row in rows:
        segment_dict[row[1]] += 1
        opcode_dict[row[4]] += 1

    segment = ",".join(["=".join([key, str(val)]) for key, val in segment_dict.items()])
    opcode = ",".join(["=".join([key, str(val)]) for key, val in opcode_dict.items()])

    return (segment, opcode)


def parse_line(line,file_in,malware_class):
    error_count = 0

    line = line.replace('\r', '').replace('\n', '')

    ############ Extract the segment ###############
    # Split on ':' and grab first section and remove the period
    split_segment_data = line.split(':')
    segment = split_segment_data[0].replace('.','')
    
    ########## Extract the address ###########
    # Address to left[0], rest of data to the right[1]
    split_address_data = split_segment_data[1].split(' ')
    # Remove any \r or \n remaining
    address = split_address_data[0].replace('\t','')
    
    ######## Extract the bytes #########
    # Use segment split and split on '\t\t' to get everything from the end of bytes to the 
    # left in element [0] and the rest of the line data to the right
    split_bytes_data = split_segment_data[1].split('\t\t')
    # Split on the first space, now bytes should be in element 1(If there are any)
    
    split_segment_bytes = split_bytes_data[0].split(' ', 1)
    
    # Check if there are bytes (opcode, operands):
    bytes = ''
    opcode= ''
    operands=''
    
    if len(split_segment_bytes) > 1:
        # Clean up
        bytes = split_segment_bytes[1].replace('\t',' ').replace('\r', ' ').replace('+', '').replace(" ", "")
        
        #####
        # NOTE: There will only be an opcode if there are bytes - so 
        # we will extract within the if statement
        ######
        ############ Extract the opcode ###########
        # Split on the last occurrence of \t that will occur after bytes
        #split_opcode = line.replace('\t', ' ')
        
        split_opcode = line.rsplit('\t',1)
        # Only proceed if there is opcode data:
        
        if len(split_opcode) > 1:
            # Strip all initial spaces
            opcode_data = split_opcode[1].lstrip()
            # Split on first space, opcode should be to left, operands to right
            
            split_opcode_operands = opcode_data.split(' ', 1)
            # Extract opcode and cleanup
            opcode = split_opcode_operands[0].replace('\r','').replace('\n', '')
            
            # STAY IN IF STATEMENT FOR OPERANDS SINCE THEY WILL ONLY BE THERE
            # IF AN OPCODE EXISTS
            ########## Extract the operands #########
            if len(split_opcode_operands) > 1:
                # Cleanup operands
                operands = split_opcode_operands[1].lstrip().replace('\r','').replace('\n','').replace(' ', '')
                
    if opcode.isalpha():
        #feature_tuple = (file_in,segment,address, bytes, opcode, operands, malware_class)       
        feature_tuple = (file_in,segment,'', '', opcode, '', malware_class)       
        error_count = error_count + 1
    else:
        feature_tuple = (file_in,segment,'','','','',malware_class)
        
    return (feature_tuple, error_count)
                    
def extract_columns(file_in, file_out,file_to_malware):
    """ 
    Takes in a filename and returns a list of tuples with the columns of each line.
    Also takes in the filename to malware in order to append to columns
    Returns: List of (Segment, Address, Bytes, opcode, operands)
    """
    if WRITE_TO_FILE:
        file_out_writer = open(file_out,'w')
        
    lines= []
    count = 0
    malware_class = get_malware_class(file_in,file_to_malware)

    f = open(file_in, 'r')
    #for x in range(50):
    #line = f.next().strip()
    for line in open(file_in, 'r'):
        (feature_tuple,error_count) = parse_line(line,file_in,malware_class)
        lines.append(feature_tuple)
        count = count + error_count

        if WRITE_TO_FILE:
            # Write line to file
            feature_line = '{0}|{1}|{2}|{3}|{4}\n'.format(segment,address,bytes,opcode,operands)
            file_out_writer.write(feature_line)

    if WRITE_TO_FILE:
        file_out_writer.close()

    # Write all lines to file
    (seg_dict, op_dict) = get_counts(lines)
    feature_tuple = (seg_dict, op_dict, file_in, malware_class)
    connect.insert_file_info(feature_tuple)
    
    return lines
    
def generate_csv_files():
    asm_path = "../train/"
    labels_file = "../labels/trainLabels.csv"

    # Build the filename -> Malware class dictionary:
    file_to_malware = utilities.get_malware_dict(labels_file)

    # Generate header
    header = get_header(feature_functions_list)

    #### Get a list of all asm files######
    asm_files = [ f for f in listdir(asm_path) if isfile(join(asm_path,f)) and f.endswith('.asm')]

    count = 1
    asm_files = asm_files
    for asm_file in asm_files:
        print("******* Processing {0} ({1}/{2})********".format(asm_file,count,len(asm_files)))
        count = count + 1

        file_in = join(asm_path,asm_file)
        new_loc = join("../parsed/",asm_file)
        
        os.rename(file_in, new_loc)

if __name__ == "__main__":
    generate_csv_files()

